---
title: "JS. Начало #9. Модули"
description: "Модули в JavaScript: экспорт, импорт, подключение"
course: "first-sem"
date: "2025-05-11"
---

_Автор: Чердаков Анатолий Сергеевич_

# **Введение**

## **Что такое модули в JavaScript?**

Модуль — обособленная часть системы. Как правило, один модуль — это один файл. Модули можно воспринимать как части конструктора, из которых собирается программа.

В модуле по умолчанию всё скрыто. Наружу предоставляется только то, что разработчики намеренно хотят предоставить — экспорты. Эту функциональность можно импортировать в других модулях и использовать.

Таким образом, модуль — это чёрный ящик с одним входом (импорт) и одним выходом (экспорт), через которые этот модуль «общается» с другими.
9-ая - упомянуть необходимость настройки сервера для корректной работы модулей в браузере (CORS, MIME-типы)
Модули можно сравнить с функциями: они решают те же проблемы, но в более крупном масштабе. Функции помогают разбивать большую задачу на мелкие, а модули — разбивать большой проект на мелкие части. Функции помогают структурировать выстраивать архитектуру решения конкретной задачи, а модули — проекта целиком.

## **Зачем использовать модули и какие проблемы они решают?**

| Без модулей | С модулями |  |
| ----- | ----- | :---- |
| Навигация и перемещение по проекту | Сложно. Чтобы поработать над двумя частями кода, придётся либо открывать файл дважды, либо прыгать между секциями файла. | Просто. Модули можно открыть параллельно и работать над ними одновременно. |
| Охват проекта целиком | Сложно, зачастую невозможно. Простыня на несколько десятков экранов не даст понять, как проект устроен, оценить его структуру и взаимосвязи между частями программы. | Сильно проще. Структура папок и файлов проекта, построенного на модулях, помогает охватить структуру и понять, как проект устроен. |
| Повторное использование кода | Затруднено, иногда вовсе исключено. Чтобы переиспользовать код из такой портянки, его необходимо отделить, почистить от лишних зависимостей, проверить его работу отдельно и встроить в новый проект. Иногда проще написать всё с нуля. | Просто. Модули можно использовать в нескольких проектах. |

## **Как модули помогают организовать код в больших проектах**

Модули в JS организуют код через:

1. Инкапсуляцию — изолируют переменные/функции, предотвращая конфликты.  
2. Структуру — разделение на файлы по логике (API, компоненты, утилиты).  
3. Зависимости — явный импорт (import/export), а не глобальные переменные.  
4. Переиспользование — общий код в отдельных модулях.  
5. Масштабируемость — новые функции добавляются как независимые модули.  
6. Оптимизацию — сборщики удаляют неиспользуемый код (tree-shaking), ленивая загрузка.

# **Экспорт и импорт модулей**

## **Что такое экспорт и импорт в ES-модулях**

ECMAScript или ES-модули Скопировать ссылку "ECMAScript или ES-модули"  
ES-модули — модульная система на уровне языка, которая появилась в спецификации ES2015. Далее, когда мы будем говорить о модулях, мы будем иметь в виду именно ES-модули.

В ES-модулях для экспорта используется ключевое слово export, а для импорта — import. При добавлении ключевого слова export выражение становится экспортированным. Экспортировать можно не только функции, но и константы. Также мы можем получить доступ к нужной функциональности в другом модуле через импорт или импортировать константы. Обратите внимание что, перечисляя названия при импорте через запятую, можно в одном импорте получить доступ сразу к нескольким переменным или функциям.

Если вдруг хотим изменить имя той функции или переменной, которую импортируем, мы можем использовать ключевое слово as. Также ключевое слово работает и со множественным импортом. Экспортировать функциональность можно также уже и после того, как она определена. Это иногда бывает полезно, если хотим описать все экспорты в конце файла. Кроме того, это же помогает изменять названия при экспорте.

```javascript  
// module1.js

// Экспортированное выражение  
export function sum(a, b) {  
  return a + b  
}

// Экспорт констант  
export const SOME\SETTINGS\FLAG = false  
export const user = {}  
export const books = ['Война и мир', 'Мастер и Маргарита']

// module2.js

// Доступ к функциональности из первого модуля  
import { sum } from './module1.js'

// Импорт констант  
import { user, books } from './module1.js'

// Изменение имени функции или переменной, которую импортируем  
import { user as admin } from './module1.js'

// Изменение имён во множественном импорте  
import { books as library, SOME\SETTINGS\FLAG as turnedOn } from './module1.js'

// Экспортируем функциональность  
const user = {}  
export { user }

// Изменяем названия при экспорте  
const user = {}  
export { user as admin }

```

export именованный и export default в чем разница

При использовании ключевого слова export рядом с функцией или переменной, мы экспортируем конкретную функцию или переменную.

У таких переменных и функций обязательно должно быть имя, потому что именно по этому имени мы будем получать доступ к ним из других модулей. Поэтому такие экспорты называются именованными — у экспортируемой функциональности есть имя и по этому же имени мы будем импортировать её в других модулях.

Существуют также экспорты по умолчанию. Когда мы из модуля экспортируем какую-то функциональность по умолчанию, мы можем опустить имя, но обязаны использовать ключевое слово default после export. Функция может не иметь имени, потому что используется экспорт по умолчанию. При импорте такой функциональности в другом модуле нам уже не требуется использовать {}. Более того, мы сразу можем использовать другое имя при импорте.

```javascript  
// sum.js

// Экспорт безымянной функции по умолчанию  
export default function (a, b) {  
  return a + b  
}

// other-module.js

// Импорт функциональности в другом модуле  
import sum from './sum.js'

// Сразу используем другое имя  
import superCoolSummator from './sum.js'

```

# **Подключение модулей в браузере**

Чтобы модули корректно работали в браузере, вам нужно убедиться, что ваш сервер отдаёт их с заголовком Content-Type, который содержит JavaScript MIME type такой как text/javascript. В противном случае вы получете ошибку проверки MIME type — "The server responded with a non-JavaScript MIME type", и браузер не сможет запустить ваш JavaScript. Большинство серверов уже имеют правильный тип для .js-файлов, но ещё не имеют нужного MIME type для .mjs-файлов. Серверы, которые уже отдают .mjs файлы корректно, включают в себя GitHub Pages и http-сервер для Node.js.

Использование \<script type="module"\>

В браузере модули работают через подключение скриптов с атрибутом type='module': 

```javascript  
<body>  
  <script src="module1.js" type="module"><script>  
  <script src="module2.js" type="module"><script>  
</body>  
```

Как работают относительные пути при импорте?  
Относительные пути при импорте в JavaScript работают относительно файла, в котором написан импорт, и используют синтаксис с точками для навигации по директориям:  
./ — текущая директория файла с импортом. 

```javascript  
import { util } from './utils.js'; // Ищет utils.js в той же папке.  
```  

../ — подняться на одну директорию выше.

```javascript  
import { config } from '../config.js'; // Ищет config.js в родительской папке.  
```  
Множественные ../ — подняться на несколько уровней.

```javascript  
import { shared } from '../../shared/shared.js'; // Подняться на два уровня вверх.  
```

## **Почему модули выполняются в строгом режиме (use strict по умолчанию)?**

Модули — это всегда use strict. 'use strict' включает строгий режим выполнения JavaScript. Эта строка должна располагаться в самом начале скрипта, иначе строгий режим не будет работать. В строгом режиме интерпретатор будет явно выбрасывать ошибки на действия, которые ранее пропускал. Если строгий режим был включён, то отключить его для файла уже нельзя. Модули в JS выполняются в строгом режиме по умолчанию (ES6+), чтобы предотвратить ошибки (например, неявные глобальные переменные), повысить безопасность, улучшить оптимизацию и обеспечить совместимость с современными возможностями языка. Из-за этого, например, this — это не window, а undefined.

# **Динамический импорт**

## **Как работает import() и когда его использовать**

Выражение import(module) загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.  
Использовать его мы можем динамически в любом месте кода.  
Пример подгрузки модуля по требованию:

```javascript  
let modulePath = prompt("Какой модуль загружать?");

import(modulePath)  
  .then(obj => <объект модуля>)  
  .catch(err => <ошибка загрузки, например если нет такого модуля>  
```

# **Практическое применение модулей**

Пример

Структура проекта :  
```js
project/  
├── index.html  
├── main.js  
└── modules/  
    ├── math.js  
    └── utils.js
```

modules/math.js 

```  javascript  
// Именованный экспорт  
export const add = (a, b) => a + b;  
export const PI= 3.14159;

// Экспорт по умолчанию  
export default function multiply(a, b) {  
  return a * b;  
}  
```

modules/utils.js  

```  javascript  
// Экспорт объекта  
export const helpers = {  
  log: (message) => console.log(`[LOG]: ${message}`),  
};  
```

Импорт в main.js  

```  javascript  
// Импорт именованных экспортов  
import { add, PI } from './modules/math.js';

// Импорт экспорта по умолчанию  
import multiply from './modules/math.js';

// Импорт всего модуля как объекта  
import * as utils from './modules/utils.js';

console.log(add(2, 3)); // 5  
console.log(multiply(2, 3)); // 6  
utils.helpers.log("Hello!"); // [LOG]: Hello!  
```

Подключите main.js в HTML  

```html  
<script type="module" src="main.js"\><script>  
```
